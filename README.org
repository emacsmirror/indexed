* Indexed
An efficient cache of metadata about all your Org files.

Builds fast.  My =M-x indexed-reset=:

#+begin_example
indexed: Analyzed 160616 lines in 10734 entries (3397 with ID)
         in 2394 files in 1.37s (+ 0.16s to build SQLite DB)
#+end_example

This library came from asking myself "what could I move out of [[https://github.com/meedstrom/org-node][org-node]], that'd make sense in core?"  Maybe a proposal for upstream, or at least a PoC.

Many Org plugins now do reinvent the wheel, when it comes to keeping track of some or many files and what may be in them.

Example: org-roam's DB, org-node's hash tables, orgrr's hash tables, ..., and some just re-run grep all the time, which still leads to writing elisp to cross-reference the results with something useful.

And let's not talk about the org-agenda... (Try putting 2000 files into =org-agenda-files=!)  It needs to open each file in real-time to know anything about them, so everyday commands grind to a halt.

** Quick overview

Data will exist after setup akin to this and you wait a second or two.

#+begin_src elisp
(setq indexed-org-dirs '("~/org" "~/Sync/notes"))
(indexed-updater-mode)
(indexed-roam-mode) ;; optional
#+end_src

Two different APIs to access the same data.

- sql
- elisp

Why two?  It's free.  When the data has been gathered anyway, there is no reason to /only/ insert it into a SQLite db, nor /only/ put it in a hash table.

And hash table is nicer for simple lookups, SQL for complex lookups.

For the elisp, see [[https://github.com/meedstrom/indexed?tab=readme-ov-file#appendix-i-api][Appendix I]]. For the SQL, see below.

** A SQLite database, for free

You can create your own database ([[https://github.com/meedstrom/indexed?tab=readme-ov-file#appendix-ii-make-your-own-database][Appendix II]]), but you probably won't need to.  Included is a drop-in for [[https://github.com/org-roam/org-roam][org-roam's]] =(org-roam-db)=, called =(indexed-roam)=.

As a plugin dev, perhaps the main thing you needed from org-roam was its SQL database.  If so, you can now make your plugins useful to a wider crowd!

Due to identical table schemata, you can convert from e.g.

#+begin_src elisp
(org-roam-db-query [:select tag :from tags :where (= id $s1)] id)
#+end_src

to

#+begin_src elisp
(sqlite-select (indexed-roam) "select tag from tags where id = ?;" (list id))
#+end_src

or if you like mysterious aliases,

#+begin_src elisp
(indexed-roam "select tag from tags where id = ?;" id)
#+end_src

*** Diskless
There is no file =org-roam.db= on disk, it lives in volatile RAM, generated on the spot.

There is little point modifying it.  Use =SELECT= queries only.

*** EmacSQL  (UPDATE 2025-03-20)

You can now use the EmacSQL s-exp language instead of raw SQL!

Even =org-roam-db-query= can work as if nothing's out of the ordinary:

#+begin_src elisp
;; Delete and replace org-roam.db
(org-roam-db-autosync-mode 0)
(setq indexed-roam-db-location org-roam-db-location)
(indexed-reset)

;; It works!
(org-roam-db-query [:select * :from files])
#+end_src

The above is only relevant if you do use org-roam.  I suggest that developers drop the dependency and require only EmacSQL, since this is the same:

#+begin_src elisp
;; Setup
(setq indexed-roam-db-location "/tmp/indexed-roam.db")
(indexed-reset)
(setq my-orgdb (emacsql-sqlite-open indexed-roam-db-location))

;; It works!
(emacsql my-orgdb [:select * :from files])
#+end_src

Of course you shouldn't set =indexed-roam-db-location= on your users' behalf, but you can throw some error if it's nil, and tell them to set it.

*** Explore DB contents

Command =M-x indexed-list-db-contents= lets you explore what's inside the database!

Compare with he corresponding elisp objects: get [[https://github.com/mmontone/emacs-inspector][Inspector]] and eval =(inspector-inspect (indexed-org-entries))=.

** Data only

A design choice: Indexed *only* delivers data.  It could easily ship conveniences like, let's call it a function "indexed-goto":

#+begin_src elisp
(defun indexed-goto (entry)
  (find-file (indexed-file-name entry))
  (goto-char (indexed-pos entry))
#+end_src

but in my experience, that will spiral into dozens of lines over time, to handle a variety of edge cases, and then it will no longer be universally applicable.  Maybe you prefer to handle edge cases different than I do.

So, it is up to you to write your own "goto" function and all else to do with user interaction.

** RFC 1: Naming

How would /you/ name a library that does what this does?

It's essentially org-roam without any UI stuff, left as an exercise for the reader.  Or org-id with more info than just IDs.

("org-lookup"? "docdb"?)

It could be extended to track other file types---AsciiDoc, Markdown, RST---so you can be cosmopolitan and switch dialects according to mood.  "This Monday's living up to its name, think I'm gonna just chill in an AsciiDoc file".  That's my official justification for not putting an "org-" prefix or some such.

My real justification is easier to read code that uses the API.

Still, just "indexed-" feels a bit weird sometimes.

** +RFC 2+
** RFC 3: Should entries with heading level zero be called something else?

The content before first heading, is now also recorded as an "entry".  This is not technically correct Org jargon.

Small distinguisher: The zeroth-level entry can never have a TODO state, priority, SCHEDULED/DEADLINE, but implementation-wise, that just means several fields are nil.

It would be good to have a simple term, because it comes up a lot when you write Org code: so often necessary to special-case behavior conditioned on whether or not =(org-before-first-heading-p)=.

** Appendix I: API

NOTE: Namespace *still under flux!*  This *may be out of date!*  Check [[https://github.com/meedstrom/indexed/blob/main/indexed.el][indexed.el]] source.

There are three types of objects: /file-data/, /org-entry/ and /org-link/.  Some functions operate on more than one type.

Polymorphic functions
- indexed-pos
- indexed-file-name
- indexed-file-data
- indexed-file-title
- indexed-file-title-or-basename
- indexed-file-mtime

Functions operating on raw file paths
- indexed-entry-near-lnum-in-file
- indexed-entry-near-pos-in-file
- indexed-id-nodes-in
- indexed-entries-in

Functions operating on raw id
- indexed-entry-by-id
- indexed-links-from

Functions operating on raw titles
- indexed-id-node-by-title

Functions operating on FILE-DATA
- indexed-mtime

Functions operating on ORG-LINK
- indexed-dest
- indexed-type
- indexed-heading-above
- indexed-id-nearby
  - (old alias: =indexed-origin= -- I'm partial to naming it =indexed-id-nearby=. What do you think?

    Org-node has used the name "origin" for a year and it works.  Org-roam uses "source".  But both presume an ID-centric design to everything, and make less sense when you allow for the absence of IDs.  It seems that "origin" could refer to /either/ an ID /or/ a file-and-position /or/ some other means of locating the link.

    Also, perhaps =indexed-id-nearby= could become polymorphic.)

Functions operating on ENTRY
- indexed-deadline
- indexed-heading-lvl
- indexed-id-links-to
- indexed-olpath
- indexed-olpath-with-self
- indexed-olpath-with-self-with-title
- indexed-olpath-with-title
- indexed-priority
- indexed-properties --- subject to change
- indexed-property --- subject to change
- indexed-property-assert --- subject to change
- indexed-roam-aliases
- indexed-roam-reflinks-to
- indexed-roam-refs
- indexed-root-heading-to
- indexed-scheduled
- indexed-tags
- indexed-tags-inherited
- indexed-tags-local
- indexed-todo-state
- indexed-toptitle

Functions without argument (which you can use to iterate over all objects)

- indexed-org-entries
- indexed-org-id-nodes (subset of above)
- indexed-org-links-and-citations
- indexed-org-links (subset of above)
- indexed-org-files

Hooks

- indexed-pre-full-reset-functions
- indexed-post-full-reset-functions
- indexed-record-file-functions
- indexed-record-entry-functions
- indexed-record-link-functions

Hooks used when =indexed-updater-mode= is enabled

- indexed-pre-incremental-update-functions
- indexed-post-incremental-update-functions
- indexed-forget-file-functions
- indexed-forget-entry-functions
- indexed-forget-link-functions

*** Extension: indexed-x.el

A separate file =indexed-x.el= is loaded when you enable =indexed-updater-mode=.

It is separate because =indexed-updater-mode= is not strictly necessary -- it could be replaced by a simple timer that calls =indexed-reset= every 30 seconds, or whatever you deem suitable.

It ships a variety of tools.

**** Programmer tool: Instantly index thing at point

You may want to call the following functions after inserting entries or links in a custom way, if they need to become indexed instantly without waiting for user to save the buffer:

- indexed-x-ensure-entry-at-point-known
- indexed-x-ensure-link-at-point-known

Examples of when those are useful is when you write a command like =org-node-extract-subtree=, or subroutine like =org-node-backlink--add-in-target=.

*** Extension: indexed-roam.el

Enabled by =indexed-roam-mode=.  Explained elsewhere.

** Appendix II: Make your own database
Steps:

1. Read indexed-roam.el as a reference implementation

   - See how it looks up the indexed data it needs.
   - See which things require a =prin1-to-string=.
   - See how arguments are ultimately passed to =sqlite-execute=.

     Alas, this file got a bit hard to read after squeezing for performance, but it can be done simpler. [TODO: write a simple reference impl]

2. Hook your own DB-creator onto =indexed-post-full-reset-functions=, or just on a repeating timer or some suitable hook.

3. Done!

** Appendix III: User stuff

Modes

- indexed-updater-mode
- indexed-roam-mode

Config settings

- indexed-warn-title-collisions
- indexed-seek-link-types --- subject to removal
- indexed-org-dirs
- indexed-org-dirs-exclude

Commands

- indexed-list-dead-id-links
- indexed-list-id-collisions
- indexed-list-title-collisions
- indexed-list-problems
- indexed-list-entries
- indexed-list-db-contents
- indexed-reset


** Tip: Fully inform org-id
# XXX update the blob link

Never sit through a slow =M-x org-id-update-id-locations= again!

#+begin_src elisp
(add-hook 'indexed-record-entry-functions #'indexed-x-snitch-to-org-id)
#+end_src

This tells org-id about all IDs that Indexed can find under =indexed-org-dirs=.

That's very good, because if you had clicked an ID-link that org-id did not know about, it would react by running =org-id-update-id-locations=, making Emacs appear to hang for as long as a minute.

Never had this problem?  If you came here from org-node or org-roam,  that's because they solve this problem for you.  I did not want to do it in this library for two reasons:

1. packaging hygiene
2. the org-id [[https://github.com/meedstrom/org-node/blob/a889ede01dbcf22668bfe718037619732169245f/org-node.el#L992-1037][Schrodinger's cat bug]]
