* Indexed
An efficient cache of metadata about all your Org files.

Builds very fast.

Numbers from my =M-x indexed-reset=:

#+begin_example
indexed: Analyzed 160616 lines in 10734 entries (3397 with ID)
         in 2394 files in 1.37s + 0.16s to build SQLite DB
#+end_example

This library came from asking myself "what could I move out of [[https://github.com/meedstrom/org-node][org-node]], that'd make sense in core?"  Maybe a proposal for upstream, or at least a PoC.

Many Org plugins now do reinvent the wheel, when it comes to keeping track of some or many files and what may be in them.

Example: org-roam's DB, org-node's hash tables, orgrr's hash tables, ..., and some just re-run grep all the time, which still leads to writing elisp to cross-reference the results with something useful.

And let's not talk about the org-agenda... (Try putting 2000 files into =org-agenda-files=!)  It needs to open each file in real-time to know anything about them, so everyday commands grind to a halt.

** Quick overview

Data will exist after setup akin to this and you wait a second or two.

#+begin_src elisp
(setq indexed-org-dirs '("~/org" "~/Sync/notes"))
(indexed-mode)
(indexed-roam-mode) ;; optional
#+end_src

Two different APIs to access the same data.

- sql
- elisp

Why two?  It's free.  When the data has been gathered anyway, there is no reason to /only/ insert it into a SQLite db, nor /only/ put it in a hash table.

And hash table is nicer for simple lookups, SQL for complex lookups.

For the elisp, see [[https://github.com/meedstrom/indexed?tab=readme-ov-file#appendix-i-api][Appendix I]]. For the SQL, see below.

** A SQLite database, for free

You can create your own database ([[https://github.com/meedstrom/indexed?tab=readme-ov-file#appendix-ii-make-your-own-database][Appendix II]]), but you probably won't need to.  Included is a near-drop-in for [[https://github.com/org-roam/org-roam][org-roam's]] =(org-roam-db)=, called =(indexed-roam)=.

As a plugin dev, perhaps the main thing you needed from org-roam was its SQL database.  If so, you can now make your plugins useful to a wider crowd!

Due to identical table schemata, you can often convert from e.g.

#+begin_src elisp
(org-roam-db-query [:select tag :from tags :where (= id $s1)] id)
#+end_src

to

#+begin_src elisp
(sqlite-select (indexed-roam) "select tag from tags where id = ?;" (list id))
#+end_src

or if you like mysterious aliases,

#+begin_src elisp
(indexed-roam "select tag from tags where id = ?;" id)
#+end_src

For now, you can't use the =[:select ...]= s-exp language from EmacSQL.  Someone would need to patch or repackage [[https://github.com/magit/emacsql/blob/main/emacsql-compiler.el][emacsql-compiler.el]] so it can format statements without quoting.

Use command =M-x indexed-list-roam-db-contents= to see what's in your database!

*** Diskless
There is no file =org-roam.db= on disk, it lives in volatile RAM, generated on the spot.

There is little point modifying it.  Use =SELECT= queries only.

*** Lists are strings

The values in =nodes.properties=, =nodes.olp= and =files.mtime= are stringified lists.  Same as in EmacSQL, but EmacSQL is smart and reads back from string for you.  Alas, this database just works with the built-in =sqlite-select=.  Do it manually:

#+begin_src elisp
(let ((results
       (sqlite-select
        (indexed-roam)
        "select properties from nodes where id = 'fde5cfe0-48e3-51ed-8c65-1ee702933925';")))
  (car (read-from-string (caar results)))))
#+end_src

Or use the elisp API instead: =(indexed-properties NODE)=.

** Data only

A design choice: Indexed *only* delivers data.  It could easily ship conveniences like, let's call it a function "indexed-goto":

#+begin_src elisp
(defun indexed-goto (entry)
  (find-file (indexed-file entry))
  (goto-char (indexed-pos entry))
#+end_src

but in my experience, that will spiral into dozens of lines over time, to handle a variety of edge cases, and then it will no longer be universally applicable.  Maybe you prefer to handle edge cases different than I do.

So, it is up to you to write your own "goto" function.

Plus, it'd sound weird -- a "goto" isn't a noun, can't be "indexed"!

** RFC 1: Naming

How would /you/ name a library that does what this does?

It's essentially org-roam without any UI stuff, left as an exercise for the reader.  Or org-id with more info than just IDs.

("org-lookup"? "docdb"?)

It could be extended to track other file types---AsciiDoc, Markdown, RST---so you can be cosmopolitan and switch dialects according to mood.  "This Monday's living up to its name, think I'm gonna just chill in an AsciiDoc file".  That's my official justification for not putting an "org-" prefix or some such.

My real justification is easier to read code that uses the API.

Still, just "indexed-" feels a bit weird sometimes.

** +RFC 2+
** RFC 3: Should entries with heading level zero be called something else?

The content before first heading, is now also recorded as an "entry".  This is not technically correct Org jargon.

Small distinguisher: The zeroth-level entry can never have a TODO state, priority, SCHEDULED/DEADLINE, but implementation-wise, that just means several fields are nil.

** Appendix I: API

NOTE: Namespace *still under flux!*  This *may be out of date!*  Check [[https://github.com/meedstrom/indexed/blob/main/indexed.el][indexed.el]] source.

There are three types of objects: /file-data/, /entry/ and /link/.  Some functions operate on more than one type.

Polymorphic functions
- indexed-pos
- indexed-file-name
- indexed-file-data
- indexed-file-title
- indexed-file-title-or-basename
- indexed-file-mtime

Functions operating on raw file paths
- indexed-entry-near-lnum-in-file
- indexed-entry-near-pos-in-file
- indexed-id-nodes-in
- indexed-entries-in

Functions operating on raw id
- indexed-entry-by-id
- indexed-links-from

Functions operating on FILE-DATA
- indexed-mtime

Functions operating on LINK
- indexed-dest
- indexed-origin
- indexed-type
- indexed-heading-above

Functions operating on ENTRY
- indexed-deadline
- indexed-heading-lvl
- indexed-id-links-to
- indexed-olpath
- indexed-olpath-with-self
- indexed-olpath-with-self-with-title
- indexed-olpath-with-title
- indexed-priority
- indexed-properties -- subject to change
- indexed-property -- subject to change
- indexed-property-assert -- subject to change
- indexed-roam-aliases
- indexed-roam-reflinks-to
- indexed-roam-refs
- indexed-root-heading-to
- indexed-scheduled
- indexed-tags
- indexed-tags-inherited
- indexed-tags-local
- indexed-todo-state
- indexed-toptitle

Functions without argument (which you can use to iterate over all objects)

- indexed-org-entries
- indexed-org-id-nodes
- indexed-org-links
- indexed-org-files

Hooks

- indexed-pre-reset-functions
- indexed-post-reset-functions
- indexed-record-file-functions
- indexed-record-entry-functions
- indexed-record-link-functions

*** Extension: indexed-x.el

Loaded by =indexed-update-on-save-mode=, which:

sets up on-save/on-rename/on-delete hooks to keep the cache updated in real time.

Provides new hooks:

- indexed-x-pre-update-functions
- indexed-x-post-update-functions
- indexed-x-forget-file-functions
- indexed-x-forget-entry-functions
- indexed-x-forget-link-functions

and also uses some already-mentioned hooks:

- indexed-record-file-functions
- indexed-record-entry-functions
- indexed-record-link-functions

You may also want to trigger the following functions after inserting entries or links, if they need to become indexed instantly even before a file is saved:

- indexed-x-ensure-entry-at-point-known
- indexed-x-ensure-link-at-point-known

*** Extension: indexed-roam.el

Enabled by =indexed-roam-mode=.  Explained elsewhere.

** Appendix II: Make your own database
Steps:

1. Read indexed-roam.el as a reference implementation

   - See how it looks up the indexed data it needs.
   - See which things require a =prin1-to-string=.
   - See how arguments are ultimately passed to =sqlite-execute=.

     Alas, this file got a bit hard to read after squeezing for performance, but it can be done simpler. [TODO: write a simple reference impl]

2. Hook your own DB-creator onto =indexed-post-reset-functions=, or just on a repeating timer or some suitable hook.

3. Done!

# In a private branch, I'm preparing functionality to keep indexing in real time without doing a full reset so often.
** Appendix III: User stuff

Modes

- indexed-mode
  - Very simple: calls =indexed-reset= occasionally.  Subject to removal.
- indexed-update-on-save-mode
  - Explained elsewhere.
- indexed-roam-mode
  - Explained elsewhere.

Config settings

- indexed-warn-title-collisions
- indexed-seek-link-types -- subject to removal
- indexed-org-dirs
- indexed-org-dirs-exclude

Commands

- indexed-list-dead-id-links
- indexed-list-id-collisions
- indexed-list-title-collisions
- indexed-list-problems
- indexed-list-entries
- indexed-list-roam-db-contents
- indexed-reset
